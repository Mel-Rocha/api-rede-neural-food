# -*- coding: utf-8 -*-
"""CC_classificacao

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1dXC0m99ice6x5Iv8hvfj7fqSFfm2rmiB
"""

import pandas as pd

nut = pd.read_csv('ABBREV.csv')

nut

nut.columns

missing_data = nut.isnull()
missing_data.head()

for column in missing_data.columns.values.tolist():
    print(column,missing_data[column].value_counts(),"")

nut_1 = nut.drop(['GmWt_1','GmWt_Desc1','GmWt_2','GmWt_Desc2','Refuse_Pct'],axis = 1)
nut_1 = nut_1.dropna()
nut_1

missing_data_1 = nut_1.isnull()
missing_data_1.head()
for column in missing_data_1.columns.values.tolist():
    print(column,missing_data_1[column].value_counts(),"")

columns = nut_1.drop(['index','NDB_No','Shrt_Desc','Energ_Kcal'],axis = 1)

contents_summary = columns.describe()
contents_summary

import pandas as pd
import plotly.graph_objects as go


# Create box plots using Plotly
fig = go.Figure()

for column in columns:
    fig.add_trace(go.Box(y=columns[column], name=column))

fig.update_layout(
    title="Distribution of food types across each Nutrient",
    yaxis_title="Values (each in its unit)",
    xaxis_title="Nutrients"
)

fig.show()

data = columns


# Calculate the quartiles for each variable
quartiles = data.quantile([0.25, 0.5, 0.75])

# Function to classify row values based on quartiles
def classify_row(row, quartiles):
    labels = []
    for column in row.index:
        q1 = quartiles.loc[0.25, column]
        q3 = quartiles.loc[0.75, column]
        if row[column] < q1:
            labels.append("Low")
        elif q1 <= row[column] <= q3:
            labels.append("Medium")
        else:
            labels.append("High")
    return pd.Series(labels, index=row.index)

# Classify rows for each column
classifications = data.apply(classify_row, axis=1, args=(quartiles,))

# Concatenate the classifications with the original data
for column in classifications.columns:
    if column not in data.columns:
        columns[column] = classifications[column]

quartiles

classifications.columns

classifications

classifications = pd.merge(nut_1['Shrt_Desc'],classifications,left_index=True, right_index=True)

classifications.tail()

def food_types_cat (nutrient,cat):
    z = pd.DataFrame(classifications[['Shrt_Desc',nutrient]][classifications[nutrient] == cat])
    return z

food_types_cat('Cholestrl_(mg)','High')

from scipy import stats
correlation_list = []

columns = nut_1.drop(['index','NDB_No','Shrt_Desc','Energ_Kcal'],axis = 1)

for i in range(45):
    for j in range(0,45):
        var1 = columns.iloc[:,i]
        var2 = columns.iloc[:,j]

        correlation, p_value = stats.pearsonr(var1,var2)
        correlation_list.append((var1.name, var2.name, correlation,p_value))

# Create a new DataFrame to store the correlation results
correlation_df = pd.DataFrame(correlation_list, columns=['Variable 1', 'Variable 2', 'Correlation','p_value'])

# Display the correlation DataFrame
correlation_df[correlation_df['Variable 1'] == 'Water_(g)']

nut_measure = nut[['Shrt_Desc', 'Water_(g)', 'Energ_Kcal',
       'Protein_(g)', 'Lipid_Tot_(g)', 'Ash_(g)', 'Carbohydrt_(g)',
       'Fiber_TD_(g)', 'Sugar_Tot_(g)']]
nut_measure

missing_data_5 = nut_measure.isnull()
missing_data_5.head()
for column in missing_data_5.columns.values.tolist():
    print(column)
    print (missing_data_5[column].value_counts())
    print("")

nut_measure = nut_measure.dropna()

nut_measure

y = nut_measure['Energ_Kcal']
X = nut_measure.drop(columns=['Energ_Kcal','Shrt_Desc'])

from sklearn.model_selection import train_test_split
from sklearn.model_selection import cross_val_score
from xgboost import XGBRegressor

X_train, X_valid, y_train, y_valid = train_test_split(X, y, train_size=0.8, test_size=0.2,
                                                      random_state=0)

def my_model(n,l,s):
    z= XGBRegressor(n_estimators=n, learning_rate=l)
    z.fit(X_train, y_train,
             early_stopping_rounds=s,
             eval_set=[(X_valid, y_valid)],
             verbose=False)
    predictions = z.predict(X_valid)
    return z

m_1 = my_model(1000,0.05,5)
scores = -1 * cross_val_score(m_1, X, y,
                              cv=5,
                              scoring='neg_mean_absolute_error')

print("Average MAE score:", scores.mean())